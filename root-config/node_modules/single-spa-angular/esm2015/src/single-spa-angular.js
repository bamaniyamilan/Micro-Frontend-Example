import { __awaiter } from "tslib";
import { getContainerElementAndSetTemplate, removeApplicationFromDOMIfIvyEnabled, } from 'single-spa-angular/internals';
import { SingleSpaPlatformLocation } from './extra-providers';
const defaultOptions = {
    // Required options that will be set by the library consumer.
    NgZone: null,
    bootstrapFunction: null,
    template: null,
    // Optional options
    Router: undefined,
    domElementGetter: undefined,
    AnimationEngine: undefined,
    updateFunction: () => Promise.resolve(),
    bootstrappedModule: null,
};
export function singleSpaAngular(userOptions) {
    if (typeof userOptions !== 'object') {
        throw Error('single-spa-angular requires a configuration object');
    }
    const options = Object.assign(Object.assign({}, defaultOptions), userOptions);
    if (typeof options.bootstrapFunction !== 'function') {
        throw Error('single-spa-angular must be passed an options.bootstrapFunction');
    }
    if (typeof options.template !== 'string') {
        throw Error('single-spa-angular must be passed options.template string');
    }
    if (!options.NgZone) {
        throw Error(`single-spa-angular must be passed the NgZone option`);
    }
    if (options.Router && !options.NavigationStart) {
        // We call `console.warn` except of throwing `new Error()` since this will not
        // be a breaking change.
        console.warn(`single-spa-angular must be passed the NavigationStart option`);
    }
    return {
        bootstrap: bootstrap.bind(null, options),
        mount: mount.bind(null, options),
        unmount: unmount.bind(null, options),
        update: options.updateFunction,
    };
}
function bootstrap(options, props) {
    return __awaiter(this, void 0, void 0, function* () {
        // Angular provides an opportunity to develop `zone-less` application, where developers
        // have to trigger change detection manually.
        // See https://angular.io/guide/zone#noopzone
        if (options.NgZone === 'noop') {
            return;
        }
        // In order for multiple Angular apps to work concurrently on a page, they each need a unique identifier.
        options.zoneIdentifier = `single-spa-angular:${props.name || props.appName}`;
        // This is a hack, since NgZone doesn't allow you to configure the property that identifies your zone.
        // See https://github.com/PlaceMe-SAS/single-spa-angular-cli/issues/33,
        // https://github.com/single-spa/single-spa-angular/issues/47,
        // https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L144,
        // and https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L257
        options.NgZone.isInAngularZone = () => {
            // @ts-ignore
            return window.Zone.current._properties[options.zoneIdentifier] === true;
        };
        options.routingEventListener = () => {
            options.bootstrappedNgZone.run(() => {
                // See https://github.com/single-spa/single-spa-angular/issues/86
                // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work
                // unless we tell Zone that something happened
            });
        };
    });
}
function mount(options, props) {
    return __awaiter(this, void 0, void 0, function* () {
        getContainerElementAndSetTemplate(options, props);
        const bootstrapPromise = options.bootstrapFunction(props);
        if (!(bootstrapPromise instanceof Promise)) {
            throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);
        }
        const module = yield bootstrapPromise;
        if (!module || typeof module.destroy !== 'function') {
            throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);
        }
        const singleSpaPlatformLocation = module.injector.get(SingleSpaPlatformLocation, null);
        const ngZoneEnabled = options.NgZone !== 'noop';
        // The user has to provide `BrowserPlatformLocation` only if his application uses routing.
        // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.
        // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use
        // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.
        if (ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {
            throw new Error(`
      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?
    `);
        }
        const bootstrappedOptions = options;
        if (ngZoneEnabled) {
            const ngZone = module.injector.get(options.NgZone);
            const zoneIdentifier = bootstrappedOptions.zoneIdentifier;
            // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`
            // function was not called.
            if (singleSpaPlatformLocation !== null) {
                skipLocationChangeOnNonImperativeRoutingTriggers(module, options);
                // Cleanup resources, especially remove event listeners thus they will not be added
                // twice when application gets bootstrapped the second time.
                module.onDestroy(() => {
                    singleSpaPlatformLocation.destroyApplication(zoneIdentifier);
                });
            }
            bootstrappedOptions.bootstrappedNgZone = ngZone;
            bootstrappedOptions.bootstrappedNgZone['_inner']._properties[zoneIdentifier] = true;
            window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);
        }
        bootstrappedOptions.bootstrappedModule = module;
        return module;
    });
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function unmount(options, props) {
    return __awaiter(this, void 0, void 0, function* () {
        if (options.Router) {
            // Workaround for https://github.com/angular/angular/issues/19079
            const router = options.bootstrappedModule.injector.get(options.Router);
            router.dispose();
        }
        if (options.routingEventListener) {
            window.removeEventListener('single-spa:routing-event', options.routingEventListener);
        }
        if (options.AnimationEngine) {
            /*
            The BrowserAnimationsModule does not clean up after itself :'(. When you unmount/destroy the main module, the
            BrowserAnimationsModule uses an AnimationRenderer thing to remove dom elements from the page. But the AnimationRenderer
            defers the actual work to the TransitionAnimationEngine to do this, and the TransitionAnimationEngine doesn't actually
            remove the dom node, but just calls "markElementAsRemoved()".
        
            See https://github.com/angular/angular/blob/db62ccf9eb46ee89366ade586365ea027bb93eb1/packages/animations/browser/src/render/transition_animation_engine.ts#L717
        
            What markAsRemovedDoes is put it into an array called "collectedLeaveElements", which is all the elements that should be removed
            after the DOM has had a chance to do any animations.
        
            See https://github.com/angular/angular/blob/master/packages/animations/browser/src/render/transition_animation_engine.ts#L525
        
            The actual dom nodes aren't removed until the TransitionAnimationEngine "flushes".
        
            See https://github.com/angular/angular/blob/db62ccf9eb46ee89366ade586365ea027bb93eb1/packages/animations/browser/src/render/transition_animation_engine.ts#L851
        
            Unfortunately, though, that "flush" will never happen, since the entire module is being destroyed and there will be no more flushes.
            So what we do in this code is force one more flush of the animations after the module is destroyed.
        
            Ideally, we would do this by getting the TransitionAnimationEngine directly and flushing it. Unfortunately, though, it's private class
            that cannot be imported and is not provided to the dependency injector. So, instead, we get its wrapper class, AnimationEngine, and then
            access its private variable reference to the TransitionAnimationEngine so that we can call flush.
            */
            const animationEngine = options.bootstrappedModule.injector.get(options.AnimationEngine);
            animationEngine._transitionEngine.flush();
        }
        options.bootstrappedModule.destroy();
        options.bootstrappedModule = null;
        // TODO: this is not an issue anymore and should be removed in the future.
        removeApplicationFromDOMIfIvyEnabled(options, props);
    });
}
function skipLocationChangeOnNonImperativeRoutingTriggers(module, options) {
    if (!options.NavigationStart) {
        // As discussed we don't do anything right now if the developer doesn't provide
        // `options.NavigationStart` since this might be a breaking change.
        return;
    }
    const router = module.injector.get(options.Router);
    const subscription = router.events.subscribe((event) => {
        if (event instanceof options.NavigationStart) {
            const currentNavigation = router.getCurrentNavigation();
            // This listener will be set up for each Angular application
            // that has routing capabilities.
            // We set `skipLocationChange` for each non-imperative navigation,
            // Angular router checks under the hood if it has to change
            // the browser URL or not.
            // If `skipLocationChange` is truthy then Angular router will not call
            // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.
            if (currentNavigation.trigger !== 'imperative') {
                currentNavigation.extras.skipLocationChange = true;
                currentNavigation.extras.replaceUrl = false;
            }
        }
    });
    module.onDestroy(() => {
        subscription.unsubscribe();
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2luZ2xlLXNwYS1hbmd1bGFyLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uL2xpYnMvc2luZ2xlLXNwYS1hbmd1bGFyLyIsInNvdXJjZXMiOlsic3JjL3NpbmdsZS1zcGEtYW5ndWxhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBR0EsT0FBTyxFQUNMLGlDQUFpQyxFQUNqQyxvQ0FBb0MsR0FDckMsTUFBTSw4QkFBOEIsQ0FBQztBQUV0QyxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUc5RCxNQUFNLGNBQWMsR0FBRztJQUNyQiw2REFBNkQ7SUFDN0QsTUFBTSxFQUFFLElBQUs7SUFDYixpQkFBaUIsRUFBRSxJQUFLO0lBQ3hCLFFBQVEsRUFBRSxJQUFLO0lBQ2YsbUJBQW1CO0lBQ25CLE1BQU0sRUFBRSxTQUFTO0lBQ2pCLGdCQUFnQixFQUFFLFNBQVM7SUFDM0IsZUFBZSxFQUFFLFNBQVM7SUFDMUIsY0FBYyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7SUFDdkMsa0JBQWtCLEVBQUUsSUFBSTtDQUN6QixDQUFDO0FBRUYsTUFBTSxVQUFVLGdCQUFnQixDQUFJLFdBQXVDO0lBQ3pFLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO1FBQ25DLE1BQU0sS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7S0FDbkU7SUFFRCxNQUFNLE9BQU8sbUNBQ1IsY0FBYyxHQUNkLFdBQVcsQ0FDZixDQUFDO0lBRUYsSUFBSSxPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSyxVQUFVLEVBQUU7UUFDbkQsTUFBTSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztLQUMvRTtJQUVELElBQUksT0FBTyxPQUFPLENBQUMsUUFBUSxLQUFLLFFBQVEsRUFBRTtRQUN4QyxNQUFNLEtBQUssQ0FBQywyREFBMkQsQ0FBQyxDQUFDO0tBQzFFO0lBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUU7UUFDbkIsTUFBTSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztLQUNwRTtJQUVELElBQUksT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUU7UUFDOUMsOEVBQThFO1FBQzlFLHdCQUF3QjtRQUN4QixPQUFPLENBQUMsSUFBSSxDQUFDLDhEQUE4RCxDQUFDLENBQUM7S0FDOUU7SUFFRCxPQUFPO1FBQ0wsU0FBUyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQThDLENBQUM7UUFDL0UsS0FBSyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQztRQUNoQyxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBOEMsQ0FBQztRQUMzRSxNQUFNLEVBQUUsT0FBTyxDQUFDLGNBQWM7S0FDL0IsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFlLFNBQVMsQ0FBQyxPQUE0QyxFQUFFLEtBQVU7O1FBQy9FLHVGQUF1RjtRQUN2Riw2Q0FBNkM7UUFDN0MsNkNBQTZDO1FBQzdDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxNQUFNLEVBQUU7WUFDN0IsT0FBTztTQUNSO1FBRUQseUdBQXlHO1FBQ3pHLE9BQU8sQ0FBQyxjQUFjLEdBQUcsc0JBQXNCLEtBQUssQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRTdFLHNHQUFzRztRQUN0Ryx1RUFBdUU7UUFDdkUsOERBQThEO1FBQzlELDJIQUEySDtRQUMzSCw4SEFBOEg7UUFDOUgsT0FBTyxDQUFDLE1BQU0sQ0FBQyxlQUFlLEdBQUcsR0FBRyxFQUFFO1lBQ3BDLGFBQWE7WUFDYixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEtBQUssSUFBSSxDQUFDO1FBQzFFLENBQUMsQ0FBQztRQUVGLE9BQU8sQ0FBQyxvQkFBb0IsR0FBRyxHQUFHLEVBQUU7WUFDbEMsT0FBTyxDQUFDLGtCQUFtQixDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ25DLGlFQUFpRTtnQkFDakUsbUdBQW1HO2dCQUNuRyw4Q0FBOEM7WUFDaEQsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUM7SUFDSixDQUFDO0NBQUE7QUFFRCxTQUFlLEtBQUssQ0FBQyxPQUFnQyxFQUFFLEtBQVU7O1FBQy9ELGlDQUFpQyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUVsRCxNQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUxRCxJQUFJLENBQUMsQ0FBQyxnQkFBZ0IsWUFBWSxPQUFPLENBQUMsRUFBRTtZQUMxQyxNQUFNLEtBQUssQ0FDVCxvR0FBb0csT0FBTyxnQkFBZ0IseUJBQXlCLENBQ3JKLENBQUM7U0FDSDtRQUVELE1BQU0sTUFBTSxHQUFxQixNQUFNLGdCQUFnQixDQUFDO1FBRXhELElBQUksQ0FBQyxNQUFNLElBQUksT0FBTyxNQUFNLENBQUMsT0FBTyxLQUFLLFVBQVUsRUFBRTtZQUNuRCxNQUFNLEtBQUssQ0FDVCwyTEFBMkwsQ0FDNUwsQ0FBQztTQUNIO1FBRUQsTUFBTSx5QkFBeUIsR0FBcUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQ3JGLHlCQUF5QixFQUN6QixJQUFJLENBQ0wsQ0FBQztRQUVGLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDO1FBRWhELDBGQUEwRjtRQUMxRixzR0FBc0c7UUFDdEcsNkZBQTZGO1FBQzdGLDJFQUEyRTtRQUMzRSxJQUFJLGFBQWEsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLHlCQUF5QixLQUFLLElBQUksRUFBRTtZQUN6RSxNQUFNLElBQUksS0FBSyxDQUFDOztLQUVmLENBQUMsQ0FBQztTQUNKO1FBRUQsTUFBTSxtQkFBbUIsR0FBRyxPQUE4QyxDQUFDO1FBRTNFLElBQUksYUFBYSxFQUFFO1lBQ2pCLE1BQU0sTUFBTSxHQUFXLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMzRCxNQUFNLGNBQWMsR0FBVyxtQkFBbUIsQ0FBQyxjQUFlLENBQUM7WUFFbkUsMEZBQTBGO1lBQzFGLDJCQUEyQjtZQUMzQixJQUFJLHlCQUF5QixLQUFLLElBQUksRUFBRTtnQkFDdEMsZ0RBQWdELENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUVsRSxtRkFBbUY7Z0JBQ25GLDREQUE0RDtnQkFDNUQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7b0JBQ3BCLHlCQUF5QixDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUMvRCxDQUFDLENBQUMsQ0FBQzthQUNKO1lBRUQsbUJBQW1CLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDO1lBQ2hELG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDcEYsTUFBTSxDQUFDLGdCQUFnQixDQUFDLDBCQUEwQixFQUFFLG1CQUFtQixDQUFDLG9CQUFxQixDQUFDLENBQUM7U0FDaEc7UUFFRCxtQkFBbUIsQ0FBQyxrQkFBa0IsR0FBRyxNQUFNLENBQUM7UUFDaEQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztDQUFBO0FBRUQsNkRBQTZEO0FBQzdELFNBQWUsT0FBTyxDQUFDLE9BQTRDLEVBQUUsS0FBVTs7UUFDN0UsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQ2xCLGlFQUFpRTtZQUNqRSxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsa0JBQW1CLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDeEUsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ2xCO1FBRUQsSUFBSSxPQUFPLENBQUMsb0JBQW9CLEVBQUU7WUFDaEMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLDBCQUEwQixFQUFFLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1NBQ3RGO1FBRUQsSUFBSSxPQUFPLENBQUMsZUFBZSxFQUFFO1lBQzNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQXVCRTtZQUNGLE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxrQkFBbUIsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUMxRixlQUFlLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDM0M7UUFFRCxPQUFPLENBQUMsa0JBQW1CLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztRQUVsQywwRUFBMEU7UUFDMUUsb0NBQW9DLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3ZELENBQUM7Q0FBQTtBQUVELFNBQVMsZ0RBQWdELENBQ3ZELE1BQXdCLEVBQ3hCLE9BQWdDO0lBRWhDLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFO1FBQzVCLCtFQUErRTtRQUMvRSxtRUFBbUU7UUFDbkUsT0FBTztLQUNSO0lBRUQsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25ELE1BQU0sWUFBWSxHQUFpQixNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQVUsRUFBRSxFQUFFO1FBQ3hFLElBQUksS0FBSyxZQUFZLE9BQU8sQ0FBQyxlQUFnQixFQUFFO1lBQzdDLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLG9CQUFvQixFQUFFLENBQUM7WUFDeEQsNERBQTREO1lBQzVELGlDQUFpQztZQUNqQyxrRUFBa0U7WUFDbEUsMkRBQTJEO1lBQzNELDBCQUEwQjtZQUMxQixzRUFBc0U7WUFDdEUsMEZBQTBGO1lBQzFGLElBQUksaUJBQWlCLENBQUMsT0FBTyxLQUFLLFlBQVksRUFBRTtnQkFDOUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztnQkFDbkQsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7YUFDN0M7U0FDRjtJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDcEIsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzdCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nTW9kdWxlUmVmLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTGlmZUN5Y2xlcyB9IGZyb20gJ3NpbmdsZS1zcGEnO1xuaW1wb3J0IHtcbiAgZ2V0Q29udGFpbmVyRWxlbWVudEFuZFNldFRlbXBsYXRlLFxuICByZW1vdmVBcHBsaWNhdGlvbkZyb21ET01JZkl2eUVuYWJsZWQsXG59IGZyb20gJ3NpbmdsZS1zcGEtYW5ndWxhci9pbnRlcm5hbHMnO1xuXG5pbXBvcnQgeyBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uIH0gZnJvbSAnLi9leHRyYS1wcm92aWRlcnMnO1xuaW1wb3J0IHsgU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMsIEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAvLyBSZXF1aXJlZCBvcHRpb25zIHRoYXQgd2lsbCBiZSBzZXQgYnkgdGhlIGxpYnJhcnkgY29uc3VtZXIuXG4gIE5nWm9uZTogbnVsbCEsXG4gIGJvb3RzdHJhcEZ1bmN0aW9uOiBudWxsISxcbiAgdGVtcGxhdGU6IG51bGwhLFxuICAvLyBPcHRpb25hbCBvcHRpb25zXG4gIFJvdXRlcjogdW5kZWZpbmVkLFxuICBkb21FbGVtZW50R2V0dGVyOiB1bmRlZmluZWQsIC8vIG9ubHkgb3B0aW9uYWwgaWYgeW91IHByb3ZpZGUgYSBkb21FbGVtZW50R2V0dGVyIGFzIGEgY3VzdG9tIHByb3BcbiAgQW5pbWF0aW9uRW5naW5lOiB1bmRlZmluZWQsXG4gIHVwZGF0ZUZ1bmN0aW9uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcbiAgYm9vdHN0cmFwcGVkTW9kdWxlOiBudWxsLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZVNwYUFuZ3VsYXI8VD4odXNlck9wdGlvbnM6IFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zPFQ+KTogTGlmZUN5Y2xlczxUPiB7XG4gIGlmICh0eXBlb2YgdXNlck9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgRXJyb3IoJ3NpbmdsZS1zcGEtYW5ndWxhciByZXF1aXJlcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0Jyk7XG4gIH1cblxuICBjb25zdCBvcHRpb25zOiBTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi51c2VyT3B0aW9ucyxcbiAgfTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuYm9vdHN0cmFwRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBFcnJvcignc2luZ2xlLXNwYS1hbmd1bGFyIG11c3QgYmUgcGFzc2VkIGFuIG9wdGlvbnMuYm9vdHN0cmFwRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBFcnJvcignc2luZ2xlLXNwYS1hbmd1bGFyIG11c3QgYmUgcGFzc2VkIG9wdGlvbnMudGVtcGxhdGUgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuTmdab25lKSB7XG4gICAgdGhyb3cgRXJyb3IoYHNpbmdsZS1zcGEtYW5ndWxhciBtdXN0IGJlIHBhc3NlZCB0aGUgTmdab25lIG9wdGlvbmApO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuUm91dGVyICYmICFvcHRpb25zLk5hdmlnYXRpb25TdGFydCkge1xuICAgIC8vIFdlIGNhbGwgYGNvbnNvbGUud2FybmAgZXhjZXB0IG9mIHRocm93aW5nIGBuZXcgRXJyb3IoKWAgc2luY2UgdGhpcyB3aWxsIG5vdFxuICAgIC8vIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICAgIGNvbnNvbGUud2Fybihgc2luZ2xlLXNwYS1hbmd1bGFyIG11c3QgYmUgcGFzc2VkIHRoZSBOYXZpZ2F0aW9uU3RhcnQgb3B0aW9uYCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJvb3RzdHJhcDogYm9vdHN0cmFwLmJpbmQobnVsbCwgb3B0aW9ucyBhcyBCb290c3RyYXBwZWRTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyksXG4gICAgbW91bnQ6IG1vdW50LmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgdW5tb3VudDogdW5tb3VudC5iaW5kKG51bGwsIG9wdGlvbnMgYXMgQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMpLFxuICAgIHVwZGF0ZTogb3B0aW9ucy51cGRhdGVGdW5jdGlvbixcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYm9vdHN0cmFwKG9wdGlvbnM6IEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zLCBwcm9wczogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIEFuZ3VsYXIgcHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGV2ZWxvcCBgem9uZS1sZXNzYCBhcHBsaWNhdGlvbiwgd2hlcmUgZGV2ZWxvcGVyc1xuICAvLyBoYXZlIHRvIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiBtYW51YWxseS5cbiAgLy8gU2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS96b25lI25vb3B6b25lXG4gIGlmIChvcHRpb25zLk5nWm9uZSA9PT0gJ25vb3AnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSW4gb3JkZXIgZm9yIG11bHRpcGxlIEFuZ3VsYXIgYXBwcyB0byB3b3JrIGNvbmN1cnJlbnRseSBvbiBhIHBhZ2UsIHRoZXkgZWFjaCBuZWVkIGEgdW5pcXVlIGlkZW50aWZpZXIuXG4gIG9wdGlvbnMuem9uZUlkZW50aWZpZXIgPSBgc2luZ2xlLXNwYS1hbmd1bGFyOiR7cHJvcHMubmFtZSB8fCBwcm9wcy5hcHBOYW1lfWA7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2ssIHNpbmNlIE5nWm9uZSBkb2Vzbid0IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHByb3BlcnR5IHRoYXQgaWRlbnRpZmllcyB5b3VyIHpvbmUuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUGxhY2VNZS1TQVMvc2luZ2xlLXNwYS1hbmd1bGFyLWNsaS9pc3N1ZXMvMzMsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5nbGUtc3BhL3NpbmdsZS1zcGEtYW5ndWxhci9pc3N1ZXMvNDcsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9hMTRkYzJkN2E0ODIxYTE5ZjIwYTk1NDcwNTNhNTczNDc5OGY1NDFlL3BhY2thZ2VzL2NvcmUvc3JjL3pvbmUvbmdfem9uZS50cyNMMTQ0LFxuICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL2ExNGRjMmQ3YTQ4MjFhMTlmMjBhOTU0NzA1M2E1NzM0Nzk4ZjU0MWUvcGFja2FnZXMvY29yZS9zcmMvem9uZS9uZ196b25lLnRzI0wyNTdcbiAgb3B0aW9ucy5OZ1pvbmUuaXNJbkFuZ3VsYXJab25lID0gKCkgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gd2luZG93LlpvbmUuY3VycmVudC5fcHJvcGVydGllc1tvcHRpb25zLnpvbmVJZGVudGlmaWVyXSA9PT0gdHJ1ZTtcbiAgfTtcblxuICBvcHRpb25zLnJvdXRpbmdFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgIG9wdGlvbnMuYm9vdHN0cmFwcGVkTmdab25lIS5ydW4oKCkgPT4ge1xuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5nbGUtc3BhL3NpbmdsZS1zcGEtYW5ndWxhci9pc3N1ZXMvODZcbiAgICAgIC8vIFpvbmUgaXMgdW5hd2FyZSBvZiB0aGUgc2luZ2xlLXNwYSBuYXZpZ2F0aW9uIGNoYW5nZSBhbmQgc28gQW5ndWxhciBjaGFuZ2UgZGV0ZWN0aW9uIGRvZXNuJ3Qgd29ya1xuICAgICAgLy8gdW5sZXNzIHdlIHRlbGwgWm9uZSB0aGF0IHNvbWV0aGluZyBoYXBwZW5lZFxuICAgIH0pO1xuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBtb3VudChvcHRpb25zOiBTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucywgcHJvcHM6IGFueSk6IFByb21pc2U8TmdNb2R1bGVSZWY8YW55Pj4ge1xuICBnZXRDb250YWluZXJFbGVtZW50QW5kU2V0VGVtcGxhdGUob3B0aW9ucywgcHJvcHMpO1xuXG4gIGNvbnN0IGJvb3RzdHJhcFByb21pc2UgPSBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uKHByb3BzKTtcblxuICBpZiAoIShib290c3RyYXBQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBzaW5nbGUtc3BhLWFuZ3VsYXI6IHRoZSBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgcHJvbWlzZSwgYnV0IGluc3RlYWQgcmV0dXJuZWQgYSAnJHt0eXBlb2YgYm9vdHN0cmFwUHJvbWlzZX0nIHRoYXQgaXMgbm90IGEgUHJvbWlzZWAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG1vZHVsZTogTmdNb2R1bGVSZWY8YW55PiA9IGF3YWl0IGJvb3RzdHJhcFByb21pc2U7XG5cbiAgaWYgKCFtb2R1bGUgfHwgdHlwZW9mIG1vZHVsZS5kZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgc2luZ2xlLXNwYS1hbmd1bGFyOiB0aGUgb3B0aW9ucy5ib290c3RyYXBGdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UgdGhhdCBkaWQgbm90IHJlc29sdmUgd2l0aCBhIHZhbGlkIEFuZ3VsYXIgbW9kdWxlLiBEaWQgeW91IGNhbGwgcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZSgpIGNvcnJlY3RseT9gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBzaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uOiBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uIHwgbnVsbCA9IG1vZHVsZS5pbmplY3Rvci5nZXQoXG4gICAgU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbixcbiAgICBudWxsLFxuICApO1xuXG4gIGNvbnN0IG5nWm9uZUVuYWJsZWQgPSBvcHRpb25zLk5nWm9uZSAhPT0gJ25vb3AnO1xuXG4gIC8vIFRoZSB1c2VyIGhhcyB0byBwcm92aWRlIGBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbmAgb25seSBpZiBoaXMgYXBwbGljYXRpb24gdXNlcyByb3V0aW5nLlxuICAvLyBTbyBpZiBoZSBwcm92aWRlZCBgUm91dGVyYCBidXQgZGlkbid0IHByb3ZpZGUgYEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uYCB0aGVuIHdlIGhhdmUgdG8gaW5mb3JtIGhpbS5cbiAgLy8gQWxzbyBgZ2V0U2luZ2xlU3BhRXh0cmFQcm92aWRlcnMoKWAgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBvbmx5IGlmIHRoZSB1c2VyIGRvZXNuJ3QgdXNlXG4gIC8vIGB6b25lLWxlc3NgIGNoYW5nZSBkZXRlY3Rpb24sIGlmIGBOZ1pvbmVgIGlzIGBub29wYCB0aGVuIHdlIGNhbiBza2lwIGl0LlxuICBpZiAobmdab25lRW5hYmxlZCAmJiBvcHRpb25zLlJvdXRlciAmJiBzaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIHNpbmdsZS1zcGEtYW5ndWxhcjogY291bGQgbm90IHJldHJpZXZlIGV4dHJhIHByb3ZpZGVycyBmcm9tIHRoZSBwbGF0Zm9ybSBpbmplY3Rvci4gRGlkIHlvdSBjYWxsIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoZ2V0U2luZ2xlU3BhRXh0cmFQcm92aWRlcnMoKSkuYm9vdHN0cmFwTW9kdWxlKCk/XG4gICAgYCk7XG4gIH1cblxuICBjb25zdCBib290c3RyYXBwZWRPcHRpb25zID0gb3B0aW9ucyBhcyBCb290c3RyYXBwZWRTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucztcblxuICBpZiAobmdab25lRW5hYmxlZCkge1xuICAgIGNvbnN0IG5nWm9uZTogTmdab25lID0gbW9kdWxlLmluamVjdG9yLmdldChvcHRpb25zLk5nWm9uZSk7XG4gICAgY29uc3Qgem9uZUlkZW50aWZpZXI6IHN0cmluZyA9IGJvb3RzdHJhcHBlZE9wdGlvbnMuem9uZUlkZW50aWZpZXIhO1xuXG4gICAgLy8gYE5nWm9uZWAgY2FuIGJlIGVuYWJsZWQgYnV0IHJvdXRpbmcgbWF5IG5vdCBiZSB1c2VkIHRodXMgYGdldFNpbmdsZVNwYUV4dHJhUHJvdmlkZXJzKClgXG4gICAgLy8gZnVuY3Rpb24gd2FzIG5vdCBjYWxsZWQuXG4gICAgaWYgKHNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gIT09IG51bGwpIHtcbiAgICAgIHNraXBMb2NhdGlvbkNoYW5nZU9uTm9uSW1wZXJhdGl2ZVJvdXRpbmdUcmlnZ2Vycyhtb2R1bGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBDbGVhbnVwIHJlc291cmNlcywgZXNwZWNpYWxseSByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHRodXMgdGhleSB3aWxsIG5vdCBiZSBhZGRlZFxuICAgICAgLy8gdHdpY2Ugd2hlbiBhcHBsaWNhdGlvbiBnZXRzIGJvb3RzdHJhcHBlZCB0aGUgc2Vjb25kIHRpbWUuXG4gICAgICBtb2R1bGUub25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgc2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbi5kZXN0cm95QXBwbGljYXRpb24oem9uZUlkZW50aWZpZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYm9vdHN0cmFwcGVkT3B0aW9ucy5ib290c3RyYXBwZWROZ1pvbmUgPSBuZ1pvbmU7XG4gICAgYm9vdHN0cmFwcGVkT3B0aW9ucy5ib290c3RyYXBwZWROZ1pvbmVbJ19pbm5lciddLl9wcm9wZXJ0aWVzW3pvbmVJZGVudGlmaWVyXSA9IHRydWU7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3NpbmdsZS1zcGE6cm91dGluZy1ldmVudCcsIGJvb3RzdHJhcHBlZE9wdGlvbnMucm91dGluZ0V2ZW50TGlzdGVuZXIhKTtcbiAgfVxuXG4gIGJvb3RzdHJhcHBlZE9wdGlvbnMuYm9vdHN0cmFwcGVkTW9kdWxlID0gbW9kdWxlO1xuICByZXR1cm4gbW9kdWxlO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5hc3luYyBmdW5jdGlvbiB1bm1vdW50KG9wdGlvbnM6IEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zLCBwcm9wczogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChvcHRpb25zLlJvdXRlcikge1xuICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE5MDc5XG4gICAgY29uc3Qgcm91dGVyID0gb3B0aW9ucy5ib290c3RyYXBwZWRNb2R1bGUhLmluamVjdG9yLmdldChvcHRpb25zLlJvdXRlcik7XG4gICAgcm91dGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJvdXRpbmdFdmVudExpc3RlbmVyKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NpbmdsZS1zcGE6cm91dGluZy1ldmVudCcsIG9wdGlvbnMucm91dGluZ0V2ZW50TGlzdGVuZXIpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuQW5pbWF0aW9uRW5naW5lKSB7XG4gICAgLypcbiAgICBUaGUgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUgZG9lcyBub3QgY2xlYW4gdXAgYWZ0ZXIgaXRzZWxmIDonKC4gV2hlbiB5b3UgdW5tb3VudC9kZXN0cm95IHRoZSBtYWluIG1vZHVsZSwgdGhlXG4gICAgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUgdXNlcyBhbiBBbmltYXRpb25SZW5kZXJlciB0aGluZyB0byByZW1vdmUgZG9tIGVsZW1lbnRzIGZyb20gdGhlIHBhZ2UuIEJ1dCB0aGUgQW5pbWF0aW9uUmVuZGVyZXJcbiAgICBkZWZlcnMgdGhlIGFjdHVhbCB3b3JrIHRvIHRoZSBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lIHRvIGRvIHRoaXMsIGFuZCB0aGUgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZSBkb2Vzbid0IGFjdHVhbGx5XG4gICAgcmVtb3ZlIHRoZSBkb20gbm9kZSwgYnV0IGp1c3QgY2FsbHMgXCJtYXJrRWxlbWVudEFzUmVtb3ZlZCgpXCIuXG5cbiAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL2RiNjJjY2Y5ZWI0NmVlODkzNjZhZGU1ODYzNjVlYTAyN2JiOTNlYjEvcGFja2FnZXMvYW5pbWF0aW9ucy9icm93c2VyL3NyYy9yZW5kZXIvdHJhbnNpdGlvbl9hbmltYXRpb25fZW5naW5lLnRzI0w3MTdcblxuICAgIFdoYXQgbWFya0FzUmVtb3ZlZERvZXMgaXMgcHV0IGl0IGludG8gYW4gYXJyYXkgY2FsbGVkIFwiY29sbGVjdGVkTGVhdmVFbGVtZW50c1wiLCB3aGljaCBpcyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICBhZnRlciB0aGUgRE9NIGhhcyBoYWQgYSBjaGFuY2UgdG8gZG8gYW55IGFuaW1hdGlvbnMuXG5cbiAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL21hc3Rlci9wYWNrYWdlcy9hbmltYXRpb25zL2Jyb3dzZXIvc3JjL3JlbmRlci90cmFuc2l0aW9uX2FuaW1hdGlvbl9lbmdpbmUudHMjTDUyNVxuXG4gICAgVGhlIGFjdHVhbCBkb20gbm9kZXMgYXJlbid0IHJlbW92ZWQgdW50aWwgdGhlIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUgXCJmbHVzaGVzXCIuXG5cbiAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL2RiNjJjY2Y5ZWI0NmVlODkzNjZhZGU1ODYzNjVlYTAyN2JiOTNlYjEvcGFja2FnZXMvYW5pbWF0aW9ucy9icm93c2VyL3NyYy9yZW5kZXIvdHJhbnNpdGlvbl9hbmltYXRpb25fZW5naW5lLnRzI0w4NTFcblxuICAgIFVuZm9ydHVuYXRlbHksIHRob3VnaCwgdGhhdCBcImZsdXNoXCIgd2lsbCBuZXZlciBoYXBwZW4sIHNpbmNlIHRoZSBlbnRpcmUgbW9kdWxlIGlzIGJlaW5nIGRlc3Ryb3llZCBhbmQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGZsdXNoZXMuXG4gICAgU28gd2hhdCB3ZSBkbyBpbiB0aGlzIGNvZGUgaXMgZm9yY2Ugb25lIG1vcmUgZmx1c2ggb2YgdGhlIGFuaW1hdGlvbnMgYWZ0ZXIgdGhlIG1vZHVsZSBpcyBkZXN0cm95ZWQuXG5cbiAgICBJZGVhbGx5LCB3ZSB3b3VsZCBkbyB0aGlzIGJ5IGdldHRpbmcgdGhlIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUgZGlyZWN0bHkgYW5kIGZsdXNoaW5nIGl0LiBVbmZvcnR1bmF0ZWx5LCB0aG91Z2gsIGl0J3MgcHJpdmF0ZSBjbGFzc1xuICAgIHRoYXQgY2Fubm90IGJlIGltcG9ydGVkIGFuZCBpcyBub3QgcHJvdmlkZWQgdG8gdGhlIGRlcGVuZGVuY3kgaW5qZWN0b3IuIFNvLCBpbnN0ZWFkLCB3ZSBnZXQgaXRzIHdyYXBwZXIgY2xhc3MsIEFuaW1hdGlvbkVuZ2luZSwgYW5kIHRoZW5cbiAgICBhY2Nlc3MgaXRzIHByaXZhdGUgdmFyaWFibGUgcmVmZXJlbmNlIHRvIHRoZSBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lIHNvIHRoYXQgd2UgY2FuIGNhbGwgZmx1c2guXG4gICAgKi9cbiAgICBjb25zdCBhbmltYXRpb25FbmdpbmUgPSBvcHRpb25zLmJvb3RzdHJhcHBlZE1vZHVsZSEuaW5qZWN0b3IuZ2V0KG9wdGlvbnMuQW5pbWF0aW9uRW5naW5lKTtcbiAgICBhbmltYXRpb25FbmdpbmUuX3RyYW5zaXRpb25FbmdpbmUuZmx1c2goKTtcbiAgfVxuXG4gIG9wdGlvbnMuYm9vdHN0cmFwcGVkTW9kdWxlIS5kZXN0cm95KCk7XG4gIG9wdGlvbnMuYm9vdHN0cmFwcGVkTW9kdWxlID0gbnVsbDtcblxuICAvLyBUT0RPOiB0aGlzIGlzIG5vdCBhbiBpc3N1ZSBhbnltb3JlIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICByZW1vdmVBcHBsaWNhdGlvbkZyb21ET01JZkl2eUVuYWJsZWQob3B0aW9ucywgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBza2lwTG9jYXRpb25DaGFuZ2VPbk5vbkltcGVyYXRpdmVSb3V0aW5nVHJpZ2dlcnMoXG4gIG1vZHVsZTogTmdNb2R1bGVSZWY8YW55PixcbiAgb3B0aW9uczogU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMsXG4pOiB2b2lkIHtcbiAgaWYgKCFvcHRpb25zLk5hdmlnYXRpb25TdGFydCkge1xuICAgIC8vIEFzIGRpc2N1c3NlZCB3ZSBkb24ndCBkbyBhbnl0aGluZyByaWdodCBub3cgaWYgdGhlIGRldmVsb3BlciBkb2Vzbid0IHByb3ZpZGVcbiAgICAvLyBgb3B0aW9ucy5OYXZpZ2F0aW9uU3RhcnRgIHNpbmNlIHRoaXMgbWlnaHQgYmUgYSBicmVha2luZyBjaGFuZ2UuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgcm91dGVyID0gbW9kdWxlLmluamVjdG9yLmdldChvcHRpb25zLlJvdXRlcik7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gcm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoKGV2ZW50OiBhbnkpID0+IHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBvcHRpb25zLk5hdmlnYXRpb25TdGFydCEpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnROYXZpZ2F0aW9uID0gcm91dGVyLmdldEN1cnJlbnROYXZpZ2F0aW9uKCk7XG4gICAgICAvLyBUaGlzIGxpc3RlbmVyIHdpbGwgYmUgc2V0IHVwIGZvciBlYWNoIEFuZ3VsYXIgYXBwbGljYXRpb25cbiAgICAgIC8vIHRoYXQgaGFzIHJvdXRpbmcgY2FwYWJpbGl0aWVzLlxuICAgICAgLy8gV2Ugc2V0IGBza2lwTG9jYXRpb25DaGFuZ2VgIGZvciBlYWNoIG5vbi1pbXBlcmF0aXZlIG5hdmlnYXRpb24sXG4gICAgICAvLyBBbmd1bGFyIHJvdXRlciBjaGVja3MgdW5kZXIgdGhlIGhvb2QgaWYgaXQgaGFzIHRvIGNoYW5nZVxuICAgICAgLy8gdGhlIGJyb3dzZXIgVVJMIG9yIG5vdC5cbiAgICAgIC8vIElmIGBza2lwTG9jYXRpb25DaGFuZ2VgIGlzIHRydXRoeSB0aGVuIEFuZ3VsYXIgcm91dGVyIHdpbGwgbm90IGNhbGxcbiAgICAgIC8vIGBzZXRCcm93c2VyVXJsKClgIHdoaWNoIGNhbGxzIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZSgpYCBhbmQgZGlzcGF0Y2hlcyBgcG9wc3RhdGVgIGV2ZW50LlxuICAgICAgaWYgKGN1cnJlbnROYXZpZ2F0aW9uLnRyaWdnZXIgIT09ICdpbXBlcmF0aXZlJykge1xuICAgICAgICBjdXJyZW50TmF2aWdhdGlvbi5leHRyYXMuc2tpcExvY2F0aW9uQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudE5hdmlnYXRpb24uZXh0cmFzLnJlcGxhY2VVcmwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIG1vZHVsZS5vbkRlc3Ryb3koKCkgPT4ge1xuICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9KTtcbn1cbiJdfQ==