import { Injectable, Inject } from '@angular/core';
import { ɵBrowserPlatformLocation, PlatformLocation, DOCUMENT, } from '@angular/common';
export class SingleSpaPlatformLocation extends ɵBrowserPlatformLocation {
    constructor() {
        super(...arguments);
        // This is a simple marker that helps us to ignore PopStateEvents
        // that was not dispatched by the browser.
        this.skipNextPopState = false;
        // The key here is an actual forked `Zone` of some specific application.
        // We will be able to find the specific zone when application gets destroyed
        // by application `name`.
        // The reason of that the `onPopState` method is invoked during `bootstrapModule`
        // and we can't know what application has invoked it. Why should we know the application
        // that has invoked `onPopState`? When application gets destroyed in a `sharing dependencies mode`
        // (when there is a single platform per all applications) we want to remove application
        // specific `popstate` listeners. E.g. if there are 2 applications:
        // * shop application adds `popstate` listener
        // * navbar application adds `popstate` listener
        // When shop application gets destroyed we want to remove only its `popstate` listener.
        this.zoneToOnPopStateListenersMap = new Map();
        // This is used only to make `Zone.wrap` happy, since it requires 2 arguments
        // and the second argument is a unique string which `zone.js` uses for debugging purposes.
        // We might want to use the application name, but we're not able to get it when `onPopState`
        // method is called during module bootstrapping.
        this.source = 0;
    }
    destroyApplication(zoneIdentifier) {
        // TLDR: Angular adds `popstate` event listener and then doesn't remove it when application gets destroyed.
        // Basically, Angular has a potentional memory leak. The `ɵBrowserPlatformLocation`
        // has `onPopState` method which adds `popstate` event listener and forgets, see here:
        // https://github.com/angular/angular/blob/14be55c9facf3e47b8c97df4502dc3f0f897da03/packages/common/src/location/platform_location.ts#L126
        const zone = [...this.zoneToOnPopStateListenersMap.keys()].find(
        // `getZoneWith` will return a zone which defines a `key` and in our case
        // we define a custom key in `single-spa-angular.ts`
        // via this line of code:
        // `_properties[zoneIdentifier] = true;`
        zone => zone.getZoneWith(zoneIdentifier) !== null);
        const onPopStateListeners = this.zoneToOnPopStateListenersMap.get(zone);
        if (Array.isArray(onPopStateListeners)) {
            for (const onPopStateListener of onPopStateListeners) {
                window.removeEventListener('popstate', onPopStateListener);
            }
        }
        this.zoneToOnPopStateListenersMap.delete(zone);
    }
    pushState(state, title, url) {
        this.skipNextPopState = true;
        super.pushState(state, title, url);
    }
    replaceState(state, title, url) {
        this.skipNextPopState = true;
        super.replaceState(state, title, url);
    }
    onPopState(fn) {
        // `Zone.current` will reference the zone that serves as an execution context
        // to some specific application, especially when `onPopState` is called.
        const zone = Zone.current;
        // Wrap any event listener into zone that is specific to some application.
        // The main issue is `back/forward` buttons of browsers, because they invoke
        // `history.back|forward` which dispatch `popstate` event. Since `single-spa`
        // overrides `history.replaceState` Angular's zone cannot intercept this event.
        // Only the root zone is able to intercept all events.
        // See https://github.com/single-spa/single-spa-angular/issues/94 for more details
        fn = zone.wrap(fn, `${this.source++}`);
        const onPopStateListener = (event) => {
            // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added
            // by `single-spa` starting from `5.4` version. We need this check because we want
            // to skip "unnatural" PopStateEvents, the one caused by `single-spa`.
            const popStateEventWasDispatchedBySingleSpa = !!event
                .singleSpa;
            if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {
                this.skipNextPopState = false;
            }
            else {
                fn(event);
            }
        };
        this.storeOnPopStateListener(zone, onPopStateListener);
        super.onPopState(onPopStateListener);
    }
    storeOnPopStateListener(zone, onPopStateListener) {
        // All listeners should be stored inside an array because the `onPopState` can be called
        // multiple times thus we wanna reference all listeners to remove them further.
        const onPopStateListeners = this.zoneToOnPopStateListenersMap.get(zone) || [];
        onPopStateListeners.push(onPopStateListener);
        if (!this.zoneToOnPopStateListenersMap.has(zone)) {
            this.zoneToOnPopStateListenersMap.set(zone, onPopStateListeners);
        }
    }
}
SingleSpaPlatformLocation.decorators = [
    { type: Injectable }
];
/**
 * The `PlatformLocation` class is an "injectee" of the `PathLocationStrategy`,
 * which creates `Subject` internally for listening on `popstate` events. We want
 * to provide this class in the most top injector that's used during bootstrapping.
 */
export function getSingleSpaExtraProviders() {
    return [
        {
            provide: SingleSpaPlatformLocation,
            useClass: SingleSpaPlatformLocation,
            deps: [[new Inject(DOCUMENT)]],
        },
        {
            provide: PlatformLocation,
            useExisting: SingleSpaPlatformLocation,
        },
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmEtcHJvdmlkZXJzLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uL2xpYnMvc2luZ2xlLXNwYS1hbmd1bGFyLyIsInNvdXJjZXMiOlsic3JjL2V4dHJhLXByb3ZpZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFrQixNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUNMLHdCQUF3QixFQUN4QixnQkFBZ0IsRUFFaEIsUUFBUSxHQUNULE1BQU0saUJBQWlCLENBQUM7QUFPekIsTUFBTSxPQUFPLHlCQUEwQixTQUFRLHdCQUF3QjtJQUR2RTs7UUFFRSxpRUFBaUU7UUFDakUsMENBQTBDO1FBQ2xDLHFCQUFnQixHQUFHLEtBQUssQ0FBQztRQUVqQyx3RUFBd0U7UUFDeEUsNEVBQTRFO1FBQzVFLHlCQUF5QjtRQUN6QixpRkFBaUY7UUFDakYsd0ZBQXdGO1FBQ3hGLGtHQUFrRztRQUNsRyx1RkFBdUY7UUFDdkYsbUVBQW1FO1FBQ25FLDhDQUE4QztRQUM5QyxnREFBZ0Q7UUFDaEQsdUZBQXVGO1FBQy9FLGlDQUE0QixHQUFHLElBQUksR0FBRyxFQUE2QixDQUFDO1FBRTVFLDZFQUE2RTtRQUM3RSwwRkFBMEY7UUFDMUYsNEZBQTRGO1FBQzVGLGdEQUFnRDtRQUN4QyxXQUFNLEdBQUcsQ0FBQyxDQUFDO0lBaUZyQixDQUFDO0lBL0VDLGtCQUFrQixDQUFDLGNBQXNCO1FBQ3ZDLDJHQUEyRztRQUMzRyxtRkFBbUY7UUFDbkYsc0ZBQXNGO1FBQ3RGLDBJQUEwSTtRQUMxSSxNQUFNLElBQUksR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLDRCQUE0QixDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSTtRQUM3RCx5RUFBeUU7UUFDekUsb0RBQW9EO1FBQ3BELHlCQUF5QjtRQUN6Qix3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxL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QUUseUJBQXlCO1NBQ3ZDO0tBQ0YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBTdGF0aWNQcm92aWRlciwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICDJtUJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLFxuICBQbGF0Zm9ybUxvY2F0aW9uLFxuICBMb2NhdGlvbkNoYW5nZUV2ZW50LFxuICBET0NVTUVOVCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxudHlwZSBPblBvcFN0YXRlTGlzdGVuZXIgPSAoZXZlbnQ6IExvY2F0aW9uQ2hhbmdlRXZlbnQpID0+IHZvaWQ7XG5cbmRlY2xhcmUgY29uc3QgWm9uZTogYW55O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbiBleHRlbmRzIMm1QnJvd3NlclBsYXRmb3JtTG9jYXRpb24ge1xuICAvLyBUaGlzIGlzIGEgc2ltcGxlIG1hcmtlciB0aGF0IGhlbHBzIHVzIHRvIGlnbm9yZSBQb3BTdGF0ZUV2ZW50c1xuICAvLyB0aGF0IHdhcyBub3QgZGlzcGF0Y2hlZCBieSB0aGUgYnJvd3Nlci5cbiAgcHJpdmF0ZSBza2lwTmV4dFBvcFN0YXRlID0gZmFsc2U7XG5cbiAgLy8gVGhlIGtleSBoZXJlIGlzIGFuIGFjdHVhbCBmb3JrZWQgYFpvbmVgIG9mIHNvbWUgc3BlY2lmaWMgYXBwbGljYXRpb24uXG4gIC8vIFdlIHdpbGwgYmUgYWJsZSB0byBmaW5kIHRoZSBzcGVjaWZpYyB6b25lIHdoZW4gYXBwbGljYXRpb24gZ2V0cyBkZXN0cm95ZWRcbiAgLy8gYnkgYXBwbGljYXRpb24gYG5hbWVgLlxuICAvLyBUaGUgcmVhc29uIG9mIHRoYXQgdGhlIGBvblBvcFN0YXRlYCBtZXRob2QgaXMgaW52b2tlZCBkdXJpbmcgYGJvb3RzdHJhcE1vZHVsZWBcbiAgLy8gYW5kIHdlIGNhbid0IGtub3cgd2hhdCBhcHBsaWNhdGlvbiBoYXMgaW52b2tlZCBpdC4gV2h5IHNob3VsZCB3ZSBrbm93IHRoZSBhcHBsaWNhdGlvblxuICAvLyB0aGF0IGhhcyBpbnZva2VkIGBvblBvcFN0YXRlYD8gV2hlbiBhcHBsaWNhdGlvbiBnZXRzIGRlc3Ryb3llZCBpbiBhIGBzaGFyaW5nIGRlcGVuZGVuY2llcyBtb2RlYFxuICAvLyAod2hlbiB0aGVyZSBpcyBhIHNpbmdsZSBwbGF0Zm9ybSBwZXIgYWxsIGFwcGxpY2F0aW9ucykgd2Ugd2FudCB0byByZW1vdmUgYXBwbGljYXRpb25cbiAgLy8gc3BlY2lmaWMgYHBvcHN0YXRlYCBsaXN0ZW5lcnMuIEUuZy4gaWYgdGhlcmUgYXJlIDIgYXBwbGljYXRpb25zOlxuICAvLyAqIHNob3AgYXBwbGljYXRpb24gYWRkcyBgcG9wc3RhdGVgIGxpc3RlbmVyXG4gIC8vICogbmF2YmFyIGFwcGxpY2F0aW9uIGFkZHMgYHBvcHN0YXRlYCBsaXN0ZW5lclxuICAvLyBXaGVuIHNob3AgYXBwbGljYXRpb24gZ2V0cyBkZXN0cm95ZWQgd2Ugd2FudCB0byByZW1vdmUgb25seSBpdHMgYHBvcHN0YXRlYCBsaXN0ZW5lci5cbiAgcHJpdmF0ZSB6b25lVG9PblBvcFN0YXRlTGlzdGVuZXJzTWFwID0gbmV3IE1hcDxhbnksIE9uUG9wU3RhdGVMaXN0ZW5lcltdPigpO1xuXG4gIC8vIFRoaXMgaXMgdXNlZCBvbmx5IHRvIG1ha2UgYFpvbmUud3JhcGAgaGFwcHksIHNpbmNlIGl0IHJlcXVpcmVzIDIgYXJndW1lbnRzXG4gIC8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgdW5pcXVlIHN0cmluZyB3aGljaCBgem9uZS5qc2AgdXNlcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAvLyBXZSBtaWdodCB3YW50IHRvIHVzZSB0aGUgYXBwbGljYXRpb24gbmFtZSwgYnV0IHdlJ3JlIG5vdCBhYmxlIHRvIGdldCBpdCB3aGVuIGBvblBvcFN0YXRlYFxuICAvLyBtZXRob2QgaXMgY2FsbGVkIGR1cmluZyBtb2R1bGUgYm9vdHN0cmFwcGluZy5cbiAgcHJpdmF0ZSBzb3VyY2UgPSAwO1xuXG4gIGRlc3Ryb3lBcHBsaWNhdGlvbih6b25lSWRlbnRpZmllcjogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gVExEUjogQW5ndWxhciBhZGRzIGBwb3BzdGF0ZWAgZXZlbnQgbGlzdGVuZXIgYW5kIHRoZW4gZG9lc24ndCByZW1vdmUgaXQgd2hlbiBhcHBsaWNhdGlvbiBnZXRzIGRlc3Ryb3llZC5cbiAgICAvLyBCYXNpY2FsbHksIEFuZ3VsYXIgaGFzIGEgcG90ZW50aW9uYWwgbWVtb3J5IGxlYWsuIFRoZSBgybVCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbmBcbiAgICAvLyBoYXMgYG9uUG9wU3RhdGVgIG1ldGhvZCB3aGljaCBhZGRzIGBwb3BzdGF0ZWAgZXZlbnQgbGlzdGVuZXIgYW5kIGZvcmdldHMsIHNlZSBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi8xNGJlNTVjOWZhY2YzZTQ3YjhjOTdkZjQ1MDJkYzNmMGY4OTdkYTAzL3BhY2thZ2VzL2NvbW1vbi9zcmMvbG9jYXRpb24vcGxhdGZvcm1fbG9jYXRpb24udHMjTDEyNlxuICAgIGNvbnN0IHpvbmUgPSBbLi4udGhpcy56b25lVG9PblBvcFN0YXRlTGlzdGVuZXJzTWFwLmtleXMoKV0uZmluZChcbiAgICAgIC8vIGBnZXRab25lV2l0aGAgd2lsbCByZXR1cm4gYSB6b25lIHdoaWNoIGRlZmluZXMgYSBga2V5YCBhbmQgaW4gb3VyIGNhc2VcbiAgICAgIC8vIHdlIGRlZmluZSBhIGN1c3RvbSBrZXkgaW4gYHNpbmdsZS1zcGEtYW5ndWxhci50c2BcbiAgICAgIC8vIHZpYSB0aGlzIGxpbmUgb2YgY29kZTpcbiAgICAgIC8vIGBfcHJvcGVydGllc1t6b25lSWRlbnRpZmllcl0gPSB0cnVlO2BcbiAgICAgIHpvbmUgPT4gem9uZS5nZXRab25lV2l0aCh6b25lSWRlbnRpZmllcikgIT09IG51bGwsXG4gICAgKTtcblxuICAgIGNvbnN0IG9uUG9wU3RhdGVMaXN0ZW5lcnM6XG4gICAgICB8IE9uUG9wU3RhdGVMaXN0ZW5lcltdXG4gICAgICB8IHVuZGVmaW5lZCA9IHRoaXMuem9uZVRvT25Qb3BTdGF0ZUxpc3RlbmVyc01hcC5nZXQoem9uZSk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvblBvcFN0YXRlTGlzdGVuZXJzKSkge1xuICAgICAgZm9yIChjb25zdCBvblBvcFN0YXRlTGlzdGVuZXIgb2Ygb25Qb3BTdGF0ZUxpc3RlbmVycykge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuem9uZVRvT25Qb3BTdGF0ZUxpc3RlbmVyc01hcC5kZWxldGUoem9uZSk7XG4gIH1cblxuICBwdXNoU3RhdGUoc3RhdGU6IGFueSwgdGl0bGU6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnNraXBOZXh0UG9wU3RhdGUgPSB0cnVlO1xuICAgIHN1cGVyLnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gIH1cblxuICByZXBsYWNlU3RhdGUoc3RhdGU6IGFueSwgdGl0bGU6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnNraXBOZXh0UG9wU3RhdGUgPSB0cnVlO1xuICAgIHN1cGVyLnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gIH1cblxuICBvblBvcFN0YXRlKGZuOiBPblBvcFN0YXRlTGlzdGVuZXIpOiB2b2lkIHtcbiAgICAvLyBgWm9uZS5jdXJyZW50YCB3aWxsIHJlZmVyZW5jZSB0aGUgem9uZSB0aGF0IHNlcnZlcyBhcyBhbiBleGVjdXRpb24gY29udGV4dFxuICAgIC8vIHRvIHNvbWUgc3BlY2lmaWMgYXBwbGljYXRpb24sIGVzcGVjaWFsbHkgd2hlbiBgb25Qb3BTdGF0ZWAgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHpvbmUgPSBab25lLmN1cnJlbnQ7XG5cbiAgICAvLyBXcmFwIGFueSBldmVudCBsaXN0ZW5lciBpbnRvIHpvbmUgdGhhdCBpcyBzcGVjaWZpYyB0byBzb21lIGFwcGxpY2F0aW9uLlxuICAgIC8vIFRoZSBtYWluIGlzc3VlIGlzIGBiYWNrL2ZvcndhcmRgIGJ1dHRvbnMgb2YgYnJvd3NlcnMsIGJlY2F1c2UgdGhleSBpbnZva2VcbiAgICAvLyBgaGlzdG9yeS5iYWNrfGZvcndhcmRgIHdoaWNoIGRpc3BhdGNoIGBwb3BzdGF0ZWAgZXZlbnQuIFNpbmNlIGBzaW5nbGUtc3BhYFxuICAgIC8vIG92ZXJyaWRlcyBgaGlzdG9yeS5yZXBsYWNlU3RhdGVgIEFuZ3VsYXIncyB6b25lIGNhbm5vdCBpbnRlcmNlcHQgdGhpcyBldmVudC5cbiAgICAvLyBPbmx5IHRoZSByb290IHpvbmUgaXMgYWJsZSB0byBpbnRlcmNlcHQgYWxsIGV2ZW50cy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmdsZS1zcGEvc2luZ2xlLXNwYS1hbmd1bGFyL2lzc3Vlcy85NCBmb3IgbW9yZSBkZXRhaWxzXG4gICAgZm4gPSB6b25lLndyYXAoZm4sIGAke3RoaXMuc291cmNlKyt9YCk7XG5cbiAgICBjb25zdCBvblBvcFN0YXRlTGlzdGVuZXIgPSAoZXZlbnQ6IExvY2F0aW9uQ2hhbmdlRXZlbnQpID0+IHtcbiAgICAgIC8vIFRoZSBgTG9jYXRpb25DaGFuZ2VFdmVudGAgZG9lc24ndCBoYXZlIHRoZSBgc2luZ2xlU3BhYCBwcm9wZXJ0eSwgc2luY2UgaXQncyBhZGRlZFxuICAgICAgLy8gYnkgYHNpbmdsZS1zcGFgIHN0YXJ0aW5nIGZyb20gYDUuNGAgdmVyc2lvbi4gV2UgbmVlZCB0aGlzIGNoZWNrIGJlY2F1c2Ugd2Ugd2FudFxuICAgICAgLy8gdG8gc2tpcCBcInVubmF0dXJhbFwiIFBvcFN0YXRlRXZlbnRzLCB0aGUgb25lIGNhdXNlZCBieSBgc2luZ2xlLXNwYWAuXG4gICAgICBjb25zdCBwb3BTdGF0ZUV2ZW50V2FzRGlzcGF0Y2hlZEJ5U2luZ2xlU3BhID0gISEoKGV2ZW50IGFzIHVua25vd24pIGFzIHsgc2luZ2xlU3BhOiBib29sZWFuIH0pXG4gICAgICAgIC5zaW5nbGVTcGE7XG5cbiAgICAgIGlmICh0aGlzLnNraXBOZXh0UG9wU3RhdGUgJiYgcG9wU3RhdGVFdmVudFdhc0Rpc3BhdGNoZWRCeVNpbmdsZVNwYSkge1xuICAgICAgICB0aGlzLnNraXBOZXh0UG9wU3RhdGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5zdG9yZU9uUG9wU3RhdGVMaXN0ZW5lcih6b25lLCBvblBvcFN0YXRlTGlzdGVuZXIpO1xuICAgIHN1cGVyLm9uUG9wU3RhdGUob25Qb3BTdGF0ZUxpc3RlbmVyKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RvcmVPblBvcFN0YXRlTGlzdGVuZXIoem9uZTogYW55LCBvblBvcFN0YXRlTGlzdGVuZXI6IE9uUG9wU3RhdGVMaXN0ZW5lcik6IHZvaWQge1xuICAgIC8vIEFsbCBsaXN0ZW5lcnMgc2hvdWxkIGJlIHN0b3JlZCBpbnNpZGUgYW4gYXJyYXkgYmVjYXVzZSB0aGUgYG9uUG9wU3RhdGVgIGNhbiBiZSBjYWxsZWRcbiAgICAvLyBtdWx0aXBsZSB0aW1lcyB0aHVzIHdlIHdhbm5hIHJlZmVyZW5jZSBhbGwgbGlzdGVuZXJzIHRvIHJlbW92ZSB0aGVtIGZ1cnRoZXIuXG4gICAgY29uc3Qgb25Qb3BTdGF0ZUxpc3RlbmVyczogT25Qb3BTdGF0ZUxpc3RlbmVyW10gPVxuICAgICAgdGhpcy56b25lVG9PblBvcFN0YXRlTGlzdGVuZXJzTWFwLmdldCh6b25lKSB8fCBbXTtcblxuICAgIG9uUG9wU3RhdGVMaXN0ZW5lcnMucHVzaChvblBvcFN0YXRlTGlzdGVuZXIpO1xuXG4gICAgaWYgKCF0aGlzLnpvbmVUb09uUG9wU3RhdGVMaXN0ZW5lcnNNYXAuaGFzKHpvbmUpKSB7XG4gICAgICB0aGlzLnpvbmVUb09uUG9wU3RhdGVMaXN0ZW5lcnNNYXAuc2V0KHpvbmUsIG9uUG9wU3RhdGVMaXN0ZW5lcnMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgUGxhdGZvcm1Mb2NhdGlvbmAgY2xhc3MgaXMgYW4gXCJpbmplY3RlZVwiIG9mIHRoZSBgUGF0aExvY2F0aW9uU3RyYXRlZ3lgLFxuICogd2hpY2ggY3JlYXRlcyBgU3ViamVjdGAgaW50ZXJuYWxseSBmb3IgbGlzdGVuaW5nIG9uIGBwb3BzdGF0ZWAgZXZlbnRzLiBXZSB3YW50XG4gKiB0byBwcm92aWRlIHRoaXMgY2xhc3MgaW4gdGhlIG1vc3QgdG9wIGluamVjdG9yIHRoYXQncyB1c2VkIGR1cmluZyBib290c3RyYXBwaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2luZ2xlU3BhRXh0cmFQcm92aWRlcnMoKTogU3RhdGljUHJvdmlkZXJbXSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbixcbiAgICAgIHVzZUNsYXNzOiBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uLFxuICAgICAgZGVwczogW1tuZXcgSW5qZWN0KERPQ1VNRU5UKV1dLFxuICAgIH0sXG4gICAge1xuICAgICAgcHJvdmlkZTogUGxhdGZvcm1Mb2NhdGlvbixcbiAgICAgIHVzZUV4aXN0aW5nOiBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uLFxuICAgIH0sXG4gIF07XG59XG4iXX0=