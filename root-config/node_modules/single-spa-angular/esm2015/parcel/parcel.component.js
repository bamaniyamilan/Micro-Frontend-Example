import { Component, ElementRef, Input, ChangeDetectionStrategy, } from '@angular/core';
export class ParcelComponent {
    constructor(host) {
        this.host = host;
        this.config = null;
        this.mountParcel = null;
        this.onParcelMount = null;
        this.wrapWith = 'div';
        this.customProps = {};
        this.appendTo = null;
        this.handleError = (error) => console.error(error);
        this.hasError = false;
        this.wrapper = null;
        this.parcel = null;
        this.task = null;
    }
    ngOnChanges() {
        this.scheduleTask("update" /* Update */, () => {
            if (this.parcel !== null && this.parcel.update) {
                return this.parcel.update(this.customProps);
            }
        });
    }
    ngOnInit() {
        this.scheduleTask("mount" /* Mount */, () => {
            if (this.mountParcel === null) {
                throw new Error('single-spa-angular: the [mountParcel] binding is required when using the <parcel> component. You can either (1) import mountRootParcel from single-spa or (2) use the mountParcel prop provided to single-spa applications.');
            }
            this.wrapper = document.createElement(this.wrapWith);
            if (this.appendTo !== null) {
                this.appendTo.appendChild(this.wrapper);
            }
            else {
                this.host.nativeElement.appendChild(this.wrapper);
            }
            this.parcel = this.mountParcel(this.config, Object.assign(Object.assign({}, this.customProps), { domElement: this.wrapper }));
            if (this.onParcelMount !== null) {
                this.parcel.mountPromise.then(this.onParcelMount);
            }
            this.unmounted = false;
            return this.parcel.mountPromise;
        });
    }
    ngOnDestroy() {
        this.scheduleTask("unmount" /* Unmount */, () => {
            if (this.parcel !== null && this.parcel.getStatus() === 'MOUNTED') {
                return this.parcel.unmount();
            }
        });
        if (this.wrapper !== null) {
            this.wrapper.parentNode.removeChild(this.wrapper);
        }
        this.unmounted = true;
    }
    scheduleTask(action, task) {
        if (this.hasError && action !== "unmount" /* Unmount */) {
            // In an error state, we don't do anything anymore except for unmounting
            return;
        }
        this.task = (this.task || Promise.resolve())
            .then(() => {
            if (this.unmounted && action !== "unmount" /* Unmount */) {
                // Never do anything once the angular component unmounts
                return;
            }
            return task();
        })
            .catch((error) => {
            this.task = Promise.resolve();
            this.hasError = true;
            if (error === null || error === void 0 ? void 0 : error.message) {
                error.message = `During '${action}', parcel threw an error: ${error.message}`;
            }
            if (typeof this.handleError === 'function') {
                this.handleError(error);
            }
            else {
                setTimeout(() => {
                    throw error;
                });
            }
            // No more things to do should be done -- the parcel is in an error state
            throw error;
        });
    }
}
ParcelComponent.decorators = [
    { type: Component, args: [{
                selector: 'parcel',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ParcelComponent.ctorParameters = () => [
    { type: ElementRef }
];
ParcelComponent.propDecorators = {
    config: [{ type: Input }],
    mountParcel: [{ type: Input }],
    onParcelMount: [{ type: Input }],
    wrapWith: [{ type: Input }],
    customProps: [{ type: Input }],
    appendTo: [{ type: Input }],
    handleError: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyY2VsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLi8uLi9saWJzL3NpbmdsZS1zcGEtYW5ndWxhci9wYXJjZWwvc3JjLyIsInNvdXJjZXMiOlsicGFyY2VsLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEVBSUwsdUJBQXVCLEdBQ3hCLE1BQU0sZUFBZSxDQUFDO0FBY3ZCLE1BQU0sT0FBTyxlQUFlO0lBZTFCLFlBQW9CLElBQTZCO1FBQTdCLFNBQUksR0FBSixJQUFJLENBQXlCO1FBZHhDLFdBQU0sR0FBd0IsSUFBSSxDQUFDO1FBQ25DLGdCQUFXLEdBQW1DLElBQUksQ0FBQztRQUNuRCxrQkFBYSxHQUF3QixJQUFJLENBQUM7UUFDMUMsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNqQixnQkFBVyxHQUFXLEVBQUUsQ0FBQztRQUN6QixhQUFRLEdBQWdCLElBQUksQ0FBQztRQUM3QixnQkFBVyxHQUFHLENBQUMsS0FBWSxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXRELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFakIsWUFBTyxHQUF1QixJQUFJLENBQUM7UUFDbkMsV0FBTSxHQUFrQixJQUFJLENBQUM7UUFDN0IsU0FBSSxHQUF5QixJQUFJLENBQUM7SUFFVSxDQUFDO0lBRXJELFdBQVc7UUFDVCxJQUFJLENBQUMsWUFBWSx3QkFBZ0IsR0FBRyxFQUFFO1lBQ3BDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7Z0JBQzlDLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQzdDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUks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QkFDZCxNQUFNLEtBQUssQ0FBQztnQkFDZCxDQUFDLENBQUMsQ0FBQzthQUNKO1lBRUQseUVBQXlFO1lBQ3pFLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDOzs7WUE1R0YsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxRQUFRO2dCQUNsQixRQUFRLEVBQUUsRUFBRTtnQkFDWixlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUNoRDs7O1lBbkJDLFVBQVU7OztxQkFxQlQsS0FBSzswQkFDTCxLQUFLOzRCQUNMLEtBQUs7dUJBQ0wsS0FBSzswQkFDTCxLQUFLO3VCQUNMLEtBQUs7MEJBQ0wsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFBhcmNlbCwgUGFyY2VsQ29uZmlnLCBBcHBQcm9wcyB9IGZyb20gJ3NpbmdsZS1zcGEnO1xuXG5jb25zdCBlbnVtIEFjdGlvbiB7XG4gIE1vdW50ID0gJ21vdW50JyxcbiAgVXBkYXRlID0gJ3VwZGF0ZScsXG4gIFVubW91bnQgPSAndW5tb3VudCcsXG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3BhcmNlbCcsXG4gIHRlbXBsYXRlOiAnJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIFBhcmNlbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKSBjb25maWc6IFBhcmNlbENvbmZpZyB8IG51bGwgPSBudWxsO1xuICBASW5wdXQoKSBtb3VudFBhcmNlbDogQXBwUHJvcHNbJ21vdW50UGFyY2VsJ10gfCBudWxsID0gbnVsbDtcbiAgQElucHV0KCkgb25QYXJjZWxNb3VudDogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gIEBJbnB1dCgpIHdyYXBXaXRoID0gJ2Rpdic7XG4gIEBJbnB1dCgpIGN1c3RvbVByb3BzOiBvYmplY3QgPSB7fTtcbiAgQElucHV0KCkgYXBwZW5kVG86IE5vZGUgfCBudWxsID0gbnVsbDtcbiAgQElucHV0KCkgaGFuZGxlRXJyb3IgPSAoZXJyb3I6IEVycm9yKSA9PiBjb25zb2xlLmVycm9yKGVycm9yKTtcblxuICBwcml2YXRlIGhhc0Vycm9yID0gZmFsc2U7XG4gIHByaXZhdGUgdW5tb3VudGVkPzogYm9vbGVhbjtcbiAgcHJpdmF0ZSB3cmFwcGVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBhcmNlbDogUGFyY2VsIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdGFzazogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaG9zdDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4pIHt9XG5cbiAgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgdGhpcy5zY2hlZHVsZVRhc2soQWN0aW9uLlVwZGF0ZSwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGFyY2VsICE9PSBudWxsICYmIHRoaXMucGFyY2VsLnVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJjZWwudXBkYXRlKHRoaXMuY3VzdG9tUHJvcHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5zY2hlZHVsZVRhc2soQWN0aW9uLk1vdW50LCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5tb3VudFBhcmNlbCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ3NpbmdsZS1zcGEtYW5ndWxhcjogdGhlIFttb3VudFBhcmNlbF0gYmluZGluZyBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIHRoZSA8cGFyY2VsPiBjb21wb25lbnQuIFlvdSBjYW4gZWl0aGVyICgxKSBpbXBvcnQgbW91bnRSb290UGFyY2VsIGZyb20gc2luZ2xlLXNwYSBvciAoMikgdXNlIHRoZSBtb3VudFBhcmNlbCBwcm9wIHByb3ZpZGVkIHRvIHNpbmdsZS1zcGEgYXBwbGljYXRpb25zLicsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy53cmFwV2l0aCk7XG5cbiAgICAgIGlmICh0aGlzLmFwcGVuZFRvICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kVG8uYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFyY2VsID0gdGhpcy5tb3VudFBhcmNlbCh0aGlzLmNvbmZpZyEsIHtcbiAgICAgICAgLi4udGhpcy5jdXN0b21Qcm9wcyxcbiAgICAgICAgZG9tRWxlbWVudDogdGhpcy53cmFwcGVyLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9uUGFyY2VsTW91bnQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJjZWwubW91bnRQcm9taXNlLnRoZW4odGhpcy5vblBhcmNlbE1vdW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51bm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcmNlbC5tb3VudFByb21pc2U7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnNjaGVkdWxlVGFzayhBY3Rpb24uVW5tb3VudCwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGFyY2VsICE9PSBudWxsICYmIHRoaXMucGFyY2VsLmdldFN0YXR1cygpID09PSAnTU9VTlRFRCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyY2VsLnVubW91bnQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLndyYXBwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMud3JhcHBlci5wYXJlbnROb2RlIS5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgc2NoZWR1bGVUYXNrKGFjdGlvbjogQWN0aW9uLCB0YXNrOiAoKSA9PiB2b2lkIHwgUHJvbWlzZTxhbnk+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFzRXJyb3IgJiYgYWN0aW9uICE9PSBBY3Rpb24uVW5tb3VudCkge1xuICAgICAgLy8gSW4gYW4gZXJyb3Igc3RhdGUsIHdlIGRvbid0IGRvIGFueXRoaW5nIGFueW1vcmUgZXhjZXB0IGZvciB1bm1vdW50aW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50YXNrID0gKHRoaXMudGFzayB8fCBQcm9taXNlLnJlc29sdmUoKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMudW5tb3VudGVkICYmIGFjdGlvbiAhPT0gQWN0aW9uLlVubW91bnQpIHtcbiAgICAgICAgICAvLyBOZXZlciBkbyBhbnl0aGluZyBvbmNlIHRoZSBhbmd1bGFyIGNvbXBvbmVudCB1bm1vdW50c1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXNrKCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy50YXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZSkge1xuICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgRHVyaW5nICcke2FjdGlvbn0nLCBwYXJjZWwgdGhyZXcgYW4gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhhbmRsZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIG1vcmUgdGhpbmdzIHRvIGRvIHNob3VsZCBiZSBkb25lIC0tIHRoZSBwYXJjZWwgaXMgaW4gYW4gZXJyb3Igc3RhdGVcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcbiAgfVxufVxuIl19