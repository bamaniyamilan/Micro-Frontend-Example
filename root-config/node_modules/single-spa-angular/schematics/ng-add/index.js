"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addNPMScripts = exports.updateConfiguration = exports.createMainEntry = exports.addDependencies = void 0;
const tslib_1 = require("tslib");
const schematics_1 = require("@angular-devkit/schematics");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const core_1 = require("@angular-devkit/core");
// The JSON5 format supports comments and all Angular projects,
// starting from version 10, contain comments in `tsconfig` files.
const json5_1 = require("json5");
const add_scripts_1 = require("./add-scripts");
const dependencies_2 = require("./dependencies");
const workspace_1 = require("./workspace");
function default_1(options) {
    return schematics_1.chain([
        addDependencies(),
        createMainEntry(options),
        updateConfiguration(options),
        addNPMScripts(options),
    ]);
}
exports.default = default_1;
function addDependencies() {
    const dependencies = [
        dependencies_2.getSingleSpaDependency(),
        dependencies_2.getSingleSpaAngularDependency(),
        dependencies_2.getAngularBuildersCustomWebpackDependency(),
    ];
    return (tree, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        var e_1, _a;
        try {
            for (var dependencies_3 = tslib_1.__asyncValues(dependencies), dependencies_3_1; dependencies_3_1 = yield dependencies_3.next(), !dependencies_3_1.done;) {
                const dependency = dependencies_3_1.value;
                dependencies_1.addPackageJsonDependency(tree, dependency);
                context.logger.info(`Added '${dependency.name}' as a dependency`);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (dependencies_3_1 && !dependencies_3_1.done && (_a = dependencies_3.return)) yield _a.call(dependencies_3);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
exports.addDependencies = addDependencies;
function createMainEntry(options) {
    return (host, context) => {
        const project = getClientProject(host, options);
        const path = core_1.normalize(project.workspace.root);
        const templateSource = schematics_1.apply(schematics_1.url('./_files'), [
            schematics_1.applyTemplates({
                prefix: project.workspace.prefix,
                routing: options.routing,
                usingBrowserAnimationsModule: options.usingBrowserAnimationsModule,
            }),
            schematics_1.move(path),
        ]);
        const rule = schematics_1.mergeWith(templateSource, schematics_1.MergeStrategy.Overwrite);
        context.logger.info(`Generated 'main.single-spa.ts`);
        context.logger.info(`Generated 'single-spa-props.ts`);
        context.logger.info(`Generated asset-url.ts`);
        context.logger.info(`Generated extra-webpack.config.js`);
        return rule(host, context);
    };
}
exports.createMainEntry = createMainEntry;
function updateConfiguration(options) {
    return (host, context) => {
        const workspace = workspace_1.getWorkspace(host);
        const project = getClientProject(host, options);
        const clientProject = workspace.projects[project.name];
        if (!clientProject.architect) {
            throw new Error('Client project architect not found.');
        }
        const workspacePath = workspace_1.getWorkspacePath(host);
        updateProjectNewAngular(context, clientProject, project.name);
        updateTSConfig(host, clientProject);
        host.overwrite(workspacePath, JSON.stringify(workspace, null, 2));
        context.logger.info(`Updated angular.json configuration`);
        // @ts-ignore
        context.logger.info(clientProject.architect.build.builder);
        return host;
    };
}
exports.updateConfiguration = updateConfiguration;
function updateProjectNewAngular(context, clientProject, projectName) {
    context.logger.info('Using @angular-devkit/custom-webpack builder.');
    const buildTarget = clientProject.architect.build;
    const browserBuilder = '@angular-builders/custom-webpack:browser';
    buildTarget.builder = browserBuilder;
    buildTarget.options.main = core_1.join(core_1.normalize(clientProject.root), core_1.normalize('src/main.single-spa.ts'));
    buildTarget.options.customWebpackConfig = {
        path: core_1.join(core_1.normalize(clientProject.root), 'extra-webpack.config.js'),
        libraryName: projectName,
        libraryTarget: 'umd',
    };
    updateConfigurationsAndDisableOutputHashing(clientProject);
    const devServerBuilder = '@angular-builders/custom-webpack:dev-server';
    clientProject.architect.serve.builder = devServerBuilder;
}
function updateTSConfig(host, clientProject) {
    const tsConfigPath = clientProject.architect.build.options.tsConfig;
    const buffer = host.read(tsConfigPath);
    if (buffer === null) {
        return;
    }
    const tsConfig = json5_1.parse(buffer.toString());
    if (!Array.isArray(tsConfig.files)) {
        return;
    }
    // The "files" property will only contain path to `main.single-spa.ts` file,
    // because we remove `polyfills` from Webpack `entry` property.
    tsConfig.files = [core_1.normalize('src/main.single-spa.ts')];
    host.overwrite(tsConfigPath, JSON.stringify(tsConfig, null, 2));
}
function addNPMScripts(options) {
    return (host) => {
        const pkgPath = '/package.json';
        const buffer = host.read(pkgPath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException('Could not find package.json');
        }
        add_scripts_1.addScripts(host, pkgPath, JSON.parse(buffer.toString()), options.project);
    };
}
exports.addNPMScripts = addNPMScripts;
function getClientProject(host, options) {
    const workspace = workspace_1.getWorkspace(host);
    let project = options.project;
    if (!options.project) {
        project = Object.keys(workspace.projects)[0];
    }
    const clientProject = workspace.projects[project];
    if (!clientProject) {
        throw new schematics_1.SchematicsException(`Client app ${options.project} not found.`);
    }
    return { name: project, workspace: clientProject };
}
function updateConfigurationsAndDisableOutputHashing(clientProject) {
    const configurations = clientProject.architect.build.configurations;
    // If the user doesn't have any `configurations` then just skip this step.
    if (typeof configurations !== 'object') {
        return;
    }
    for (const configuration of Object.values(configurations)) {
        configuration.outputHashing = 'none';
    }
}
//# sourceMappingURL=index.js.map